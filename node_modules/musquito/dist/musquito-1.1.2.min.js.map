{"version":3,"sources":["webpack://$buzz/webpack/universalModuleDefinition","webpack://$buzz/webpack/bootstrap","webpack://$buzz/./src/Utility.js","webpack://$buzz/./src/Engine.js","webpack://$buzz/./src/Loader.js","webpack://$buzz/./src/Emitter.js","webpack://$buzz/./src/Queue.js","webpack://$buzz/./src/Buzz.js","webpack://$buzz/./src/Heap.js","webpack://$buzz/./src/Sound.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Utility","_classCallCheck","this","_navigator","_contextType","_formats","navigator","AudioContext","webkitAudioContext","audio","Audio","mp3","Boolean","canPlayType","replace","mpeg","opus","ogg","oga","wav","aac","caf","m4a","mp4","weba","webm","dolby","flac","Math","round","Date","now","random","format","formats","_this","find","isFormatSupported","source","ext","isBase64","exec","toLowerCase","sources","_this2","isSourceSupported","str","test","userAgent","maxTouchPoints","msMaxTouchPoints","ErrorType","NoAudio","LoadError","PlayError","EngineError","EngineState","NotReady","Ready","Suspending","Suspended","Resuming","Destroying","Done","EngineEvents","Add","Remove","Volume","Mute","Pause","Stop","Suspend","Resume","Error","userInputEventNames","engine","Engine","_id","utility","id","_muted","_volume","_cleanUpInterval","_autoEnable","_intervalId","_isAudioAvailable","_state","_context","_gainNode","_queue","_heap","_loader","Heap","Queue","_resumeAndRemoveListeners","args","getContext","_fire","type","error","_ref","volume","muted","cleanUpInterval","autoEnable","onadd","onremove","onstop","onpause","onmute","onvolume","onsuspend","onresume","onerror","ondone","on","Loader","state","forEach","eventName","document","addEventListener","createGain","gain","setValueAtTime","currentTime","connect","destination","setInterval","free","urls","load","unload","vol","undefined","sounds","sound","stop","add","suspend","then","run","_this3","resume","_this4","cleanUp","clearInterval","destroy","dispose","clear","emitter","remove","terminate","close","handler","once","arguments","length","off","idOrUrl","groupId","Sound","_gain","idle","_len","Array","_key","fire","apply","_Emitter2","default","concat","_this5","_Utility","DownloadStatus","Success","Failure","DownloadResult","url","status","context","_bufferCache","_progressCallsAndCallbacks","_disposed","_load","Promise","all","map","isArray","_unload","resolve","push","reject","err","decodeAudioData","arrayBuffer","buffer","data","atob","split","dataView","Uint8Array","charCodeAt","req","XMLHttpRequest","open","responseType","response","send","Emitter","_objectsEventsHandlersMap","_hasObject","objEvents","_hasEvent","filter","eventSubscriber","eventSubscribers","setTimeout","subscriber","_eventActions","actionIdentifier","action","removeAfterRun","hasEvent","fn","keys","_run","hasAction","queued","_Engine","_Loader","BuzzState","Destroyed","BuzzEvents","Load","UnLoad","PlayStart","PlayEnd","Seek","Rate","FadeStart","FadeEnd","FadeStop","Destroy","LoadState","NotLoaded","Loading","Loaded","Buzz","_src","_format","_sprite","_rate","_loop","_preload","_autoplay","_buffer","_duration","_compatibleSrc","_loadState","_engine","_fading","_fadeTimer","setup","_onEngineResume","isAudioAvailable","_typeof","src","sprite","rate","loop","autoplay","preload","onload","onunload","onplaystart","onplayend","onrate","onseek","ondestroy","play","isLoaded","getCompatibleSource","downloadResult","duration","_onLoadFailure","indexOf","getSupportedFormat","getSupportedSource","soundOrId","_play","newSoundId","playSound","soundArgs","playEndCallback","destroyCallback","fadeEndCallback","positions","startPos","endPos","newSound","_removePlayActions","fadeStop","_sounds","pause","isGroup","mute","unmute","to","fade","clearTimeout","seek","isPlaying","playAndFire","$buzz","method","result","_Engine2","HeapItem","HeapItemCollection","items","soundId","toString","values","item","soundGroupId","isPaused","itemsArray","_collections","col","_toConsumableArray","SoundState","Playing","Paused","_bufferSourceNode","_startPos","_endPos","_currentPos","_rateSeek","_startTime","_playEndCallback","_destroyCallback","_fadeEndCallback","max","createBufferSource","playbackRate","_setLoop","_destroyBufferNode","startTime","start","noteGrainOn","linearRampToValueAtTime","exponentialRampToValueAtTime","cancelScheduledValues","realTime","rateElapsed","disconnect","noteGrainOff","removeEventListener","_onEnded","loopStart","loopEnd"],"mappings":"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","file":"musquito-1.1.2.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"$buzz\"] = factory();\n\telse\n\t\troot[\"$buzz\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","/**\n * Contains helper methods.\n */\nclass Utility {\n\n  /**\n   * The navigator object.\n   * @type {Navigator}\n   * @private\n   */\n  _navigator = null;\n\n  /**\n   * The AudioContext type.\n   * @type {Function}\n   * @private\n   */\n  _contextType = null;\n\n  /**\n   * Dictionary of audio formats and their support status.\n   * @type {object}\n   * @private\n   */\n  _formats = {};\n\n  /**\n   * @constructor\n   */\n  constructor() {\n    if (typeof navigator !== 'undefined') {\n      this._navigator = navigator;\n    }\n\n    // Set the available Web Audio Context type available in browser.\n    if (typeof AudioContext !== 'undefined') {\n      this._contextType = AudioContext;\n    } else if (typeof webkitAudioContext !== 'undefined') {\n      this._contextType = webkitAudioContext;\n    }\n\n    // Determine the supported audio formats.\n    let audio = new Audio();\n\n    this._formats = {\n      mp3: Boolean(audio.canPlayType('audio/mp3;').replace(/^no$/, '')),\n      mpeg: Boolean(audio.canPlayType('audio/mpeg;').replace(/^no$/, '')),\n      opus: Boolean(audio.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, '')),\n      ogg: Boolean(audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')),\n      oga: Boolean(audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')),\n      wav: Boolean(audio.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, '')),\n      aac: Boolean(audio.canPlayType('audio/aac;').replace(/^no$/, '')),\n      caf: Boolean(audio.canPlayType('audio/x-caf;').replace(/^no$/, '')),\n      m4a: Boolean((audio.canPlayType('audio/x-m4a;') ||\n        audio.canPlayType('audio/m4a;') ||\n        audio.canPlayType('audio/aac;')).replace(/^no$/, '')),\n      mp4: Boolean((audio.canPlayType('audio/x-mp4;') ||\n        audio.canPlayType('audio/mp4;') ||\n        audio.canPlayType('audio/aac;')).replace(/^no$/, '')),\n      weba: Boolean(audio.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n      webm: Boolean(audio.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n      dolby: Boolean(audio.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, '')),\n      flac: Boolean((audio.canPlayType('audio/x-flac;') || audio.canPlayType('audio/flac;')).replace(/^no$/, ''))\n    };\n\n    audio = null;\n  }\n\n  /**\n   * Returns an unique id (credit: https://howlerjs.com).\n   * @return {number}\n   */\n  id() {\n    return Math.round(Date.now() * Math.random());\n  }\n\n  /**\n   * Returns the available context type.\n   * @return {Function}\n   */\n  getContextType() {\n    return this._contextType;\n  }\n\n  /**\n   * Instantiates and returns the audio context.\n   * @return {AudioContext|webkitAudioContext}\n   */\n  getContext() {\n    return new this._contextType();\n  }\n\n  /**\n   * Returns the supported audio formats.\n   * @return {Object}\n   */\n  supportedFormats() {\n    return this._formats;\n  }\n\n  /**\n   * Returns true if the passed format is supported.\n   * @param {string} format The audio format ex. \"mp3\"\n   * @return {boolean}\n   */\n  isFormatSupported(format) {\n    return Boolean(this._formats[format]);\n  }\n\n  /**\n   * Returns the first supported format from the passed array.\n   * @param {string[]} formats Array of audio formats\n   * @return {string}\n   */\n  getSupportedFormat(formats) {\n    return formats.find(format => this.isFormatSupported(format));\n  }\n\n  /**\n   * Returns true if the audio source is supported.\n   * @param {string} source The audio source url or base64 string\n   * @return {boolean}\n   */\n  isSourceSupported(source) {\n    let ext = this.isBase64(source) ?\n      (/^data:audio\\/([^;,]+);/i).exec(source) :\n      (/^.+\\.([^.]+)$/).exec(source);\n\n    ext = (/^.+\\.([^.]+)$/).exec(source);\n    return ext ? this.isFormatSupported(ext[1].toLowerCase()) : false;\n  }\n\n  /**\n   * Returns the first supported audio source from the passed array.\n   * @param {string[]} sources Array of audio sources. The audio source could be either url or base64 string.\n   * @return {string}\n   */\n  getSupportedSource(sources) {\n    return sources.find(source => this.isSourceSupported(source));\n  }\n\n  /**\n   * Returns whether the passed string is a base64 string or not.\n   * @param {string} str Base64 audio string\n   * @return {boolean}\n   */\n  isBase64(str) {\n    return (/^data:[^;]+;base64,/).test(str);\n  }\n\n  /**\n   * Returns true if the platform is mobile.\n   * @return {boolean}\n   * @private\n   */\n  _isMobile() {\n    if (!this._navigator) {\n      return false;\n    }\n\n    return (/iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i).test(this._navigator.userAgent);\n  }\n\n  /**\n   * Returns true if the platform is touch supported.\n   * @return {boolean}\n   * @private\n   */\n  _isTouch() {\n    return typeof window !== 'undefined' && (Boolean(('ontouchend' in window) ||\n      (this._navigator && this._navigator.maxTouchPoints > 0) ||\n      (this._navigator && this._navigator.msMaxTouchPoints > 0)));\n  }\n}\n\nexport default new Utility();\n\n","import Loader from './Loader';\nimport emitter from './Emitter';\nimport Heap from './Heap';\nimport Queue from './Queue';\nimport utility from './Utility';\nimport Sound from './Sound';\n\n/**\n * Enum that represents the different type of errors thrown by Engine and Buzzes.\n * @enum {string}\n */\nconst ErrorType = {\n  NoAudio: 'no-audio',\n  LoadError: 'load',\n  PlayError: 'play',\n  EngineError: 'engine'\n};\n\n/**\n * Represents the different states of the audio engine.\n * @enum {string}\n */\nconst EngineState = {\n  NotReady: 'notready',\n  Ready: 'ready',\n  Suspending: 'suspending',\n  Suspended: 'suspended',\n  Resuming: 'resuming',\n  Destroying: 'destroying',\n  Done: 'done',\n  NoAudio: 'no-audio'\n};\n\n/**\n * Enum that represents the different events by engine.\n * @enum {string}\n */\nconst EngineEvents = {\n  Add: 'add',\n  Remove: 'remove',\n  Volume: 'volume',\n  Mute: 'mute',\n  Pause: 'pause',\n  Stop: 'stop',\n  Suspend: 'suspend',\n  Resume: 'resume',\n  Error: 'error',\n  Done: 'done'\n};\n\n/**\n * Array of event names.\n * @type {string[]}\n */\nconst userInputEventNames = [\n  'click',\n  'contextmenu',\n  'auxclick',\n  'dblclick',\n  'mousedown',\n  'mouseup',\n  'pointerup',\n  'touchend',\n  'keydown',\n  'keyup'\n];\n\n/**\n * The audio engine that orchestrates all the sounds.\n * @class\n */\nclass Engine {\n\n  /**\n   * Unique id of the engine.\n   * @type {number}\n   * @private\n   */\n  _id = utility.id();\n\n  /**\n   * Represents whether the audio engine is currently muted or not.\n   * @type {boolean}\n   * @private\n   */\n  _muted = false;\n\n  /**\n   * Represents the global volume.\n   * @type {number}\n   * @private\n   */\n  _volume = 1.0;\n\n  /**\n   * The heap clean-up period.\n   * @type {number}\n   * @private\n   */\n  _cleanUpInterval = 5;\n\n  /**\n   * Auto-enables audio in first user interaction.\n   * @type {boolean}\n   * @private\n   */\n  _autoEnable = true;\n\n  /**\n   * The clean-up interval id.\n   * @type {number|null}\n   * @private\n   */\n  _intervalId = null;\n\n  /**\n   * True if Web Audio API is available.\n   * @type {boolean}\n   * @private\n   */\n  _isAudioAvailable = false;\n\n  /**\n   * Represents the current state of the engine.\n   * @type {EngineState}\n   * @private\n   */\n  _state = EngineState.NotReady;\n\n  /**\n   * The Web Audio API's audio context.\n   * @type {AudioContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * The master gain node.\n   * @type {GainNode}\n   * @private\n   */\n  _gainNode = null;\n\n  /**\n   * The action queue.\n   * @type {Queue}\n   * @private\n   */\n  _queue = null;\n\n  /**\n   * The sound heap.\n   * @type {Heap}\n   * @private\n   */\n  _heap = null;\n\n  /**\n   * Loader - the component that loads audio buffers with audio data.\n   * @type {Loader}\n   * @private\n   */\n  _loader = null;\n\n  /**\n   * Instantiates the heap and action queue.\n   * @constructor\n   */\n  constructor() {\n    this._heap = new Heap();\n    this._queue = new Queue();\n    this._resumeAndRemoveListeners = this._resumeAndRemoveListeners.bind(this);\n  }\n\n  /**\n   * Instantiate the audio context and other dependencies.\n   * @param {object} [args] Input parameters object.\n   * @param {number} [args.volume = 1.0] The global volume of the sound engine.\n   * @param {boolean} [args.muted = false] Stay muted initially or not.\n   * @param {number} [args.cleanUpInterval = 5] The heap clean-up interval period in minutes.\n   * @param {boolean} [args.autoEnable = true] Auto-enables audio in first user interaction.\n   * @param {function} [args.onadd] Event-handler for the \"add\" event.\n   * @param {function} [args.onremove] Event-handler for the \"remove\" event.\n   * @param {function} [args.onstop] Event-handler for the \"stop\" event.\n   * @param {function} [args.onpause] Event-handler for the \"pause\" event.\n   * @param {function} [args.onmute] Event-handler for the \"mute\" event.\n   * @param {function} [args.onvolume] Event-handler for the \"volume\" event.\n   * @param {function} [args.onsuspend] Event-handler for the \"suspend\" event.\n   * @param {function} [args.onresume] Event-handler for the \"resume\" event.\n   * @param {function} [args.onerror] Event-handler for the \"error\" event.\n   * @param {function} [args.ondone] Event-handler for the \"done\" event.\n   * @return {Engine}\n   */\n  setup(args) {\n    // If the setup is already done return.\n    if (this._state !== EngineState.NotReady) {\n      return this;\n    }\n\n    this._context = utility.getContext();\n\n    // Determine the audio stuff available in the current platform and set the flags accordingly.\n    this._isAudioAvailable = Boolean(this._context);\n\n    // If no Web Audio and HTML5 audio is available fire an error event.\n    if (!this._isAudioAvailable) {\n      this._state = EngineState.NoAudio;\n      this._fire(EngineEvents.Error, { type: ErrorType.NoAudio, error: 'Web Audio API is not available' });\n      return this;\n    }\n\n    // Read the input parameters from the options.\n    const {\n      volume,\n      muted,\n      cleanUpInterval,\n      autoEnable,\n      onadd,\n      onremove,\n      onstop,\n      onpause,\n      onmute,\n      onvolume,\n      onsuspend,\n      onresume,\n      onerror,\n      ondone\n    } = args || {};\n\n    // Set the properties from the read parameters.\n    typeof volume === 'number' && volume >= 0 && volume <= 1.0 && (this._volume = volume);\n    typeof muted === 'boolean' && (this._muted = muted);\n    typeof cleanUpInterval === 'number' && (this._cleanUpInterval = cleanUpInterval);\n    typeof autoEnable === 'boolean' && (this._autoEnable = autoEnable);\n    typeof onadd === 'function' && this.on(EngineEvents.Add, onadd);\n    typeof onremove === 'function' && this.on(EngineEvents.Remove, onremove);\n    typeof onstop === 'function' && this.on(EngineEvents.Stop, onstop);\n    typeof onpause === 'function' && this.on(EngineEvents.Pause, onpause);\n    typeof onmute === 'function' && this.on(EngineEvents.Mute, onmute);\n    typeof onvolume === 'function' && this.on(EngineEvents.Volume, onvolume);\n    typeof onsuspend === 'function' && this.on(EngineEvents.Suspend, onsuspend);\n    typeof onresume === 'function' && this.on(EngineEvents.Resume, onresume);\n    typeof onerror === 'function' && this.on(EngineEvents.Error, onerror);\n    typeof ondone === 'function' && this.on(EngineEvents.Done, ondone);\n\n    // Create the buffer loader.\n    this._loader = new Loader(this._context);\n\n    // Auto-enable audio in first user interaction.\n    // https://developers.google.com/web/updates/2018/11/web-audio-autoplay#moving-forward\n    if (this._autoEnable && this._context.state === 'suspended') {\n      userInputEventNames.forEach(eventName => document.addEventListener(eventName, this._resumeAndRemoveListeners));\n    }\n\n    // Create the audio graph.\n    this._gainNode = this._context.createGain();\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : this._volume, this._context.currentTime);\n    this._gainNode.connect(this._context.destination);\n\n    this._intervalId = window.setInterval(this._heap.free, this._cleanUpInterval * 60 * 1000);\n\n    this._state = this._context.state !== 'suspended' ? EngineState.Ready : EngineState.Suspended;\n\n    return this;\n  }\n\n  /**\n   * Loads single or multiple audio resources into audio buffers and returns them.\n   * @param {string|string[]} urls Single or array of audio urls.\n   * @return {Promise}\n   */\n  load(urls) {\n    return this._loader.load(urls);\n  }\n\n  /**\n   * Unloads single or multiple loaded audio buffers from cache.\n   * @param {string|string[]} [urls] Single or array of audio urls.\n   * @return {Engine}\n   */\n  unload(urls) {\n    this._loader.unload(urls);\n    return this;\n  }\n\n  /**\n   * Mutes the engine.\n   * @return {Engine}\n   */\n  mute() {\n    // If the engine is already muted return.\n    if (this._muted) {\n      return this;\n    }\n\n    // Set the value of gain node to 0.\n    this._gainNode.gain.setValueAtTime(0, this._context.currentTime);\n\n    // Set the muted property true.\n    this._muted = true;\n\n    // Fire the \"mute\" event.\n    this._fire(EngineEvents.Mute, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Un-mutes the engine.\n   * @return {Engine}\n   */\n  unmute() {\n    // If the engine is not muted return.\n    if (!this._muted) {\n      return this;\n    }\n\n    // Reset the gain node's value back to volume.\n    this._gainNode.gain.setValueAtTime(this._volume, this._context.currentTime);\n\n    // Set the muted property to false.\n    this._muted = false;\n\n    // Fire the \"mute\" event.\n    this._fire(EngineEvents.Mute, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the volume for the audio engine that controls global volume for all sounds.\n   * @param {number} [vol] Should be within 0.0 to 1.0.\n   * @return {Engine|number}\n   */\n  volume(vol) {\n    // If no parameter is passed then return the current volume.\n    if (vol === undefined) {\n      return this._volume;\n    }\n\n    // If passed volume is not an acceptable value return.\n    if (typeof vol !== 'number' || vol < 0 || vol > 1.0) {\n      return this;\n    }\n\n    // Set the gain's value to the passed volume.\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : vol, this._context.currentTime);\n\n    // Set the volume to the property.\n    this._volume = vol;\n\n    // Fire the \"volume\" event.\n    this._fire(EngineEvents.Volume, this._volume);\n\n    return this;\n  }\n\n  /**\n   * Stops all the currently playing sounds.\n   * @return {Engine}\n   */\n  stop() {\n    // Stop all the sounds.\n    this._heap.sounds().forEach(sound => sound.stop());\n\n    // Fire the \"stop\" event.\n    this._fire(EngineEvents.Stop);\n\n    return this;\n  }\n\n  /**\n   * Stops all the playing sounds and suspends the audio context immediately.\n   * @return {Engine}\n   */\n  suspend() {\n    // If the context is resuming then suspend after resumed.\n    if (this._state === EngineState.Resuming) {\n      this._queue.add('after-resume', 'suspend', () => this.suspend());\n      return this;\n    }\n\n    // If the state is not ready return.\n    if (this._state !== EngineState.Ready) {\n      return this;\n    }\n\n    // Stop all the playing sounds.\n    this.stop();\n\n    // Set the state to suspending.\n    this._state = EngineState.Suspending;\n\n    // Suspend the Audio Context.\n    this._context.suspend().then(() => {\n      this._state = EngineState.Suspended;\n      this._queue.run('after-suspend');\n      this._fire(EngineEvents.Suspend);\n    });\n\n    return this;\n  }\n\n  /**\n   * Resumes the audio context from the suspended mode.\n   * @return {Engine}\n   */\n  resume() {\n    // If the context is suspending then resume after suspended.\n    if (this._state === EngineState.Suspending) {\n      this._queue.add('after-suspend', 'resume', () => this.resume());\n      return this;\n    }\n\n    if (this._state !== EngineState.Suspended) {\n      return this;\n    }\n\n    this._state = EngineState.Resuming;\n\n    this._context.resume().then(() => {\n      this._state = EngineState.Ready;\n      this._queue.run('after-resume');\n      this._fire(EngineEvents.Resume);\n    });\n\n    return this;\n  }\n\n  /**\n   * Shuts down the engine.\n   * @return {Engine}\n   */\n  terminate() {\n    if (this._state === EngineState.Done || this._state === EngineState.Destroying) {\n      return this;\n    }\n\n    const cleanUp = () => {\n      // Un-listen from user input events.\n      userInputEventNames.forEach(eventName => document.addEventListener(eventName, this._resumeAndRemoveListeners));\n\n      // Stop the timer.\n      this._intervalId && window.clearInterval(this._intervalId);\n      this._intervalId = null;\n\n      // Destroy the heap.\n      this._heap.destroy();\n      this._heap = null;\n\n      // Clear the cache and remove the loader.\n      if (this._loader) {\n        this._loader.dispose();\n        this._loader = null;\n      }\n\n      this._context = null;\n      this._queue.clear();\n      this._queue = null;\n      this._state = EngineState.Done;\n\n      // Fire the \"done\" event.\n      this._fire(EngineEvents.Done);\n\n      emitter.clear(this._id);\n    };\n\n    // Close the context.\n    if (this._context) {\n      if (this._state === EngineState.Suspending) {\n        this._queue.remove('after-suspend');\n        this._queue.add('after-suspend', 'destroy', () => this.terminate());\n        return this;\n      } else if (this._state === EngineState.Resuming) {\n        this._queue.remove('after-resume');\n        this._queue.add('after-resume', 'destroy', () => this.terminate());\n        return this;\n      }\n\n      this._state = EngineState.Destroying;\n      this._context && this._context.close().then(() => cleanUp());\n    } else {\n      this._state = EngineState.Destroying;\n      cleanUp();\n    }\n\n    return this;\n  }\n\n  /**\n   * Subscribes to an event.\n   * @param {string} eventName Name of the event.\n   * @param {function} handler The event-handler function.\n   * @param {boolean} [once = false] Is it one-time subscription or not.\n   * @return {Engine}\n   */\n  on(eventName, handler, once = false) {\n    emitter.on(this._id, eventName, handler, once);\n    return this;\n  }\n\n  /**\n   * Un-subscribes from an event.\n   * @param {string} eventName The event name.\n   * @param {function} [handler] The handler function.\n   * @return {Engine}\n   */\n  off(eventName, handler) {\n    emitter.off(this._id, eventName, handler);\n    return this;\n  }\n\n  /**\n   * Returns the existing sound in heap or create a new one and return.\n   * @param {number|string} idOrUrl The sound id or audio url/base64 string.\n   * @param {number} [groupId] The group id.\n   * @param {object} [args] The sound creation arguments.\n   * @return {Sound}\n   */\n  sound(idOrUrl, groupId, args) {\n    if (typeof idOrUrl === 'number') {\n      return this._heap.sound(idOrUrl);\n    }\n\n    const sound = new Sound(args);\n    this._heap.add(idOrUrl, groupId, sound);\n    sound._gain().connect(this._gainNode);\n\n    return sound;\n  }\n\n  /**\n   * Returns the sounds belongs to a group or all the sounds from the heap.\n   * @param {number} [groupId] The group id.\n   * @return {Array<Sound>}\n   */\n  sounds(groupId) {\n    return this._heap.sounds(groupId);\n  }\n\n  /**\n   * Destroys the sounds belong to the passed group.\n   * @param {boolean} idle True to destroy only the idle sounds.\n   * @param {number} groupId The group id.\n   * @return {Engine}\n   */\n  free(idle, groupId) {\n    this._heap.free(idle, groupId);\n    return this;\n  }\n\n  /**\n   * Returns whether the engine is currently muted or not.\n   * @return {boolean}\n   */\n  muted() {\n    return this._muted;\n  }\n\n  /**\n   * Returns the state of the engine.\n   * @return {EngineState}\n   */\n  state() {\n    return this._state;\n  }\n\n  /**\n   * Returns the created audio context.\n   * @return {AudioContext}\n   */\n  context() {\n    return this._context;\n  }\n\n  /**\n   * Returns true if Web Audio API is available.\n   * @return {boolean}\n   */\n  isAudioAvailable() {\n    return this._isAudioAvailable;\n  }\n\n  /**\n   * Fires an event of engine.\n   * @param {string} eventName The event name.\n   * @param {...*} args The arguments that to be passed to handler.\n   * @return {Engine}\n   * @private\n   */\n  _fire(eventName, ...args) {\n    emitter.fire(this._id, eventName, ...args, this);\n    return this;\n  }\n\n  /**\n   * Resume the context and un-listen from user input events.\n   * @private\n   */\n  _resumeAndRemoveListeners() {\n    this.resume();\n    userInputEventNames.forEach(eventName => document.addEventListener(eventName, this._resumeAndRemoveListeners));\n  }\n}\n\nconst engine = new Engine();\nexport { engine as default, EngineState, EngineEvents, ErrorType };\n","import utility from './Utility';\n\n/**\n * Enum to represent the download status of audio resource.\n * @enum {string}\n */\nconst DownloadStatus = {\n  Success: 'success',\n  Failure: 'error'\n};\n\n/**\n * Represents the download result of an audio.\n * @class\n */\nclass DownloadResult {\n\n  /**\n   * The url of the audio resource\n   * @type {string|null}\n   */\n  url = null;\n\n  /**\n   * AudioBuffer or Html5Audio element\n   * @type {AudioBuffer|Audio}\n   */\n  value = null;\n\n  /**\n   * Download error\n   * @type {any}\n   */\n  error = null;\n\n  /**\n   * Success or failure status of download.\n   * @type {DownloadStatus}\n   */\n  status = null;\n\n  /**\n   * @param {string|null} url The url of the audio resource\n   * @param {AudioBuffer|Audio} [value] AudioBuffer or Html5Audio element\n   * @param {*} [error] Download error\n   */\n  constructor(url, value, error) {\n    this.url = url;\n    this.value = value;\n    this.error = error || null;\n    this.status = error ? DownloadStatus.Failure : DownloadStatus.Success;\n  }\n}\n\n/**\n * Loads the audio sources into audio buffers and returns them.\n * The loaded buffers are cached.\n * @class\n */\nclass Loader {\n\n  /**\n   * AudioContext.\n   * @type {AudioContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * In-memory audio buffer cache store.\n   * @type {object}\n   * @private\n   */\n  _bufferCache = {};\n\n  /**\n   * Dictionary to store the current progress calls and their callbacks.\n   * @type {object}\n   * @private\n   */\n  _progressCallsAndCallbacks = {};\n\n  /**\n   * True if the loader is disposed.\n   * @type {boolean}\n   * @private\n   */\n  _disposed = false;\n\n  /**\n   * Create the cache.\n   * @param {AudioContext} context The Audio Context\n   */\n  constructor(context) {\n    this._context = context;\n  }\n\n  /**\n   * Loads single or multiple audio resources into audio buffers.\n   * @param {string|string[]} urls Single or array of audio urls\n   * @return {Promise<DownloadResult|Array<DownloadResult>>}\n   */\n  load(urls) {\n    if (typeof urls === 'string') {\n      return this._load(urls);\n    }\n\n    return Promise.all(urls.map(url => this._load(url)));\n  }\n\n  /**\n   * Removes the cached audio buffers.\n   * @param {string|string[]} [urls] Single or array of audio urls\n   */\n  unload(urls) {\n    if (typeof urls === 'string') {\n      this._unload(urls);\n      return;\n    }\n\n    if (Array.isArray(urls)) {\n      urls.forEach(url => this._unload(url), this);\n      return;\n    }\n\n    this._bufferCache = {};\n  }\n\n  /**\n   * Dispose the loader.\n   */\n  dispose() {\n    if (this._disposed) {\n      return;\n    }\n\n    this.unload();\n    this._bufferCache = {};\n    this._progressCallsAndCallbacks = null;\n    this._context = null;\n    this._disposed = true;\n  }\n\n  /**\n   * Loads a single audio resource into audio buffer and cache result if the download is succeeded.\n   * @param {string} url The Audio url\n   * @return {Promise<DownloadResult>}\n   * @private\n   */\n  _load(url) {\n    return new Promise(resolve => {\n      if (this._bufferCache.hasOwnProperty(url)) {\n        resolve(new DownloadResult(url, this._bufferCache[url]));\n        return;\n      }\n\n      if (this._progressCallsAndCallbacks.hasOwnProperty(url)) {\n        this._progressCallsAndCallbacks[url].push(resolve);\n        return;\n      }\n\n      this._progressCallsAndCallbacks[url] = [];\n      this._progressCallsAndCallbacks[url].push(resolve);\n\n      const reject = err => {\n        if (this._disposed) {\n          return;\n        }\n\n        this._progressCallsAndCallbacks[url].forEach(r => r(new DownloadResult(url, null, err)));\n        delete this._progressCallsAndCallbacks[url];\n      };\n\n      const decodeAudioData = arrayBuffer => {\n        if (this._disposed) {\n          return;\n        }\n\n        this._context.decodeAudioData(arrayBuffer, buffer => {\n          this._bufferCache[url] = buffer;\n          this._progressCallsAndCallbacks[url].forEach(r => r(new DownloadResult(url, buffer)));\n          delete this._progressCallsAndCallbacks[url];\n        }, reject);\n      };\n\n      if (utility.isBase64(url)) {\n        const data = atob(url.split(',')[1]);\n        const dataView = new Uint8Array(data.length); // eslint-disable-line no-undef\n\n        for (let i = 0; i < data.length; ++i) {\n          dataView[i] = data.charCodeAt(i);\n        }\n\n        decodeAudioData(dataView);\n        return;\n      }\n\n      const req = new XMLHttpRequest();\n      req.open('GET', url, true);\n      req.responseType = 'arraybuffer';\n\n      req.addEventListener('load', () => decodeAudioData(req.response), false);\n      req.addEventListener('error', reject, false);\n      req.send();\n    });\n  }\n\n  /**\n   * Removes the single cached audio buffer.\n   * @param {string} url Audio url\n   * @private\n   */\n  _unload(url) {\n    delete this._bufferCache[url];\n  }\n}\n\nexport { Loader as default, DownloadResult, DownloadStatus };\n","/**\n * Singleton global event emitter.\n * @class\n */\nclass Emitter {\n\n  /**\n   * Dictionary that maps the objects with their events and handlers.\n   * @type {object}\n   * @private\n   */\n  _objectsEventsHandlersMap = {};\n\n  /**\n   * Subscribes to an event of the passed object.\n   * @param {number} id The unique id of the object.\n   * @param {string} eventName Name of the event\n   * @param {function} handler The event-handler function\n   * @param {boolean} [once = false] Is it one-time subscription or not?\n   * @return {Emitter}\n   */\n  on(id, eventName, handler, once = false) {\n    if (!this._hasObject(id)) {\n      this._objectsEventsHandlersMap[id] = {};\n    }\n\n    const objEvents = this._objectsEventsHandlersMap[id];\n\n    if (!objEvents.hasOwnProperty(eventName)) {\n      objEvents[eventName] = [];\n    }\n\n    objEvents[eventName].push({\n      handler: handler,\n      once: once\n    });\n\n    return this;\n  }\n\n  /**\n   * Un-subscribes from an event of the passed object.\n   * @param {number} id The unique id of the object.\n   * @param {string} eventName The event name.\n   * @param {function} [handler] The handler function.\n   * @return {Emitter}\n   */\n  off(id, eventName, handler) {\n    if (!this._hasEvent(id, eventName)) {\n      return this;\n    }\n\n    const objEvents = this._objectsEventsHandlersMap[id];\n\n    if (!handler) {\n      objEvents[eventName] = [];\n    } else {\n      objEvents[eventName] = objEvents[eventName].filter(eventSubscriber => {\n        return eventSubscriber.handler !== handler;\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Fires an event of the object passing the source and other optional arguments.\n   * @param {number} id The unique id of the object.\n   * @param {string} eventName The event name\n   * @param {...*} args The arguments that to be passed to handler\n   * @return {Emitter}\n   */\n  fire(id, eventName, ...args) {\n    if (!this._hasEvent(id, eventName)) {\n      return this;\n    }\n\n    let eventSubscribers = this._objectsEventsHandlersMap[id][eventName];\n\n    for (let i = 0; i < eventSubscribers.length; i++) {\n      let eventSubscriber = eventSubscribers[i];\n\n      setTimeout(function (subscriber) {\n        const { handler, once } = subscriber;\n\n        handler(...args);\n\n        if (once) {\n          this.off(id, eventName, handler);\n        }\n      }.bind(this, eventSubscriber), 0);\n    }\n\n    return this;\n  }\n\n  /**\n   * Clears the event handlers of the passed object.\n   * @param {number} [id] The unique id of the object.\n   * @return {Emitter}\n   */\n  clear(id) {\n    if (!id) {\n      this._objectsEventsHandlersMap = {};\n      return this;\n    }\n\n    if (this._hasObject(id)) {\n      delete this._objectsEventsHandlersMap[id];\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns true if the object is already registered.\n   * @param {number} id The object id.\n   * @return {boolean}\n   * @private\n   */\n  _hasObject(id) {\n    return this._objectsEventsHandlersMap.hasOwnProperty(id);\n  }\n\n  /**\n   * Returns true if the passed object has an entry of the passed event.\n   * @param {number} id The object id.\n   * @param {string} eventName The event name.\n   * @return {boolean}\n   * @private\n   */\n  _hasEvent(id, eventName) {\n    return this._hasObject(id) && this._objectsEventsHandlersMap[id].hasOwnProperty(eventName);\n  }\n}\n\nexport default new Emitter();\n","/**\n * Stores queue of actions that has to be run before or after specific events.\n */\nclass Queue {\n\n  _eventActions = {};\n\n  /**\n   * Queues the passed action to the event.\n   * @param {string} eventName The event name.\n   * @param {string} actionIdentifier The action identifier.\n   * @param {function} action The action function.\n   * @param {boolean} [removeAfterRun = true] Remove the action once it's run.\n   */\n  add(eventName, actionIdentifier, action, removeAfterRun = true) {\n    if (!this.hasEvent(eventName)) {\n      this._eventActions[eventName] = {};\n    }\n\n    this._eventActions[eventName][actionIdentifier] = { fn: action, removeAfterRun: removeAfterRun };\n  }\n\n  /**\n   * Returns true if there is a event exists for the passed name.\n   * @param {string} eventName The event name.\n   * @return {boolean}\n   */\n  hasEvent(eventName) {\n    return this._eventActions.hasOwnProperty(eventName);\n  }\n\n  /**\n   * Returns true if the passed action is already queued-up.\n   * @param {string} eventName The event name.\n   * @param {string} actionIdentifier The action identifier.\n   * @return {boolean}\n   */\n  hasAction(eventName, actionIdentifier) {\n    if (!this.hasEvent(eventName)) {\n      return false;\n    }\n\n    return this._eventActions[eventName].hasOwnProperty(actionIdentifier);\n  }\n\n  /**\n   * Runs all the actions queued up for the passed event.\n   * @param {string} eventName The event name.\n   * @param {string} [actionIdentifier] The action identifier.\n   */\n  run(eventName, actionIdentifier) {\n    if (!this.hasEvent(eventName)) {\n      return;\n    }\n\n    if (typeof actionIdentifier !== 'undefined') {\n      if (!this.hasAction(eventName, actionIdentifier)) {\n        return;\n      }\n\n      this._run(eventName, actionIdentifier);\n\n      return;\n    }\n\n    Object.keys(this._eventActions[eventName]).forEach(action => this._run(eventName, action));\n  }\n\n  /**\n   * Removes the event or a queued action for the event.\n   * @param {string} eventName The event name.\n   * @param {string} [actionIdentifier] The action identifier.\n   */\n  remove(eventName, actionIdentifier) {\n    if (!this._eventActions.hasOwnProperty(eventName)) {\n      return;\n    }\n\n    if (!actionIdentifier) {\n      delete this._eventActions[eventName];\n      return;\n    }\n\n    delete this._eventActions[eventName][actionIdentifier];\n  }\n\n  /**\n   * Clears all the stored events and the queued-up actions.\n   */\n  clear() {\n    this._eventActions = {};\n  }\n\n  /**\n   * Runs a single action.\n   * @param {string} eventName The event name.\n   * @param {string} actionIdentifier The action identifier.\n   * @private\n   */\n  _run(eventName, actionIdentifier) {\n    const queued = this._eventActions[eventName][actionIdentifier];\n    queued.fn();\n    queued.removeAfterRun && this.remove(eventName, actionIdentifier);\n  }\n}\n\nexport default Queue;\n","import engine, { EngineEvents, EngineState, ErrorType } from './Engine';\nimport Queue                                            from './Queue';\nimport utility                                          from './Utility';\nimport emitter                                          from './Emitter';\nimport { DownloadStatus }                               from './Loader';\n\n/**\n * Enum that represents the different states of a sound group (buzz).\n * @enum {string}\n */\nconst BuzzState = {\n  Ready: 'ready',\n  Destroyed: 'destroyed'\n};\n\n/**\n * Enum that represents the different events fired by a buzz.\n * @enum {string}\n */\nconst BuzzEvents = {\n  Load: 'load',\n  UnLoad: 'unload',\n  PlayStart: 'playstart',\n  PlayEnd: 'playend',\n  Pause: 'pause',\n  Stop: 'stop',\n  Volume: 'volume',\n  Mute: 'mute',\n  Seek: 'seek',\n  Rate: 'rate',\n  FadeStart: 'fadestart',\n  FadeEnd: 'fadeend',\n  FadeStop: 'fadestop',\n  Error: 'error',\n  Destroy: 'destroy'\n};\n\n/**\n * Enum that represents the different states occurs while loading a sound.\n * @enum {string}\n */\nconst LoadState = {\n  NotLoaded: 'notloaded',\n  Loading: 'loading',\n  Loaded: 'loaded'\n};\n\n/**\n * A wrapper class that simplifies dealing with group of sounds.\n */\nclass Buzz {\n\n  /**\n   * Unique id.\n   * @type {number}\n   * @private\n   */\n  _id = -1;\n\n  /**\n   * Represents the source of the sound. The source can be an url or base64 string.\n   * @type {*}\n   * @private\n   */\n  _src = null;\n\n  /**\n   * The formats of the passed audio sources.\n   * @type {Array<string>}\n   * @private\n   */\n  _format = [];\n\n  /**\n   * The sprite definition.\n   * @type {object}\n   * @private\n   */\n  _sprite = null;\n\n  /**\n   * The current volume of the sound. Should be from 0.0 to 1.0.\n   * @type {number}\n   * @private\n   */\n  _volume = 1.0;\n\n  /**\n   * The current rate of the playback. Should be from 0.5 to 5.\n   * @type {number}\n   * @private\n   */\n  _rate = 1;\n\n  /**\n   * True if the sound is currently muted.\n   * @type {boolean}\n   * @private\n   */\n  _muted = false;\n\n  /**\n   * True if the sound should play repeatedly.\n   * @type {boolean}\n   * @private\n   */\n  _loop = false;\n\n  /**\n   * True to pre-loaded the sound on construction.\n   * @type {boolean}\n   * @private\n   */\n  _preload = false;\n\n  /**\n   * True to auto-play the sound on construction.\n   * @type {boolean}\n   * @private\n   */\n  _autoplay = false;\n\n  /**\n   * The audio buffer.\n   * @type {AudioBuffer}\n   * @private\n   */\n  _buffer = null;\n\n  /**\n   * Duration of the playback in seconds.\n   * @type {number}\n   * @private\n   */\n  _duration = 0;\n\n  /**\n   * The best compatible source in the audio sources passed.\n   * @type {string|null}\n   * @private\n   */\n  _compatibleSrc = null;\n\n  /**\n   * Represents the different states that occurs while loading the sound.\n   * @type {LoadState}\n   * @private\n   */\n  _loadState = LoadState.NotLoaded;\n\n  /**\n   * Represents the state of this group.\n   * @type {BuzzState}\n   * @private\n   */\n  _state = BuzzState.Ready;\n\n  /**\n   * The action queue.\n   * @type {Queue}\n   * @private\n   */\n  _queue = null;\n\n  /**\n   * The audio engine.\n   * @type {Engine}\n   * @private\n   */\n  _engine = null;\n\n  /**\n   * True if the group is currently fading.\n   * @type {boolean}\n   * @private\n   */\n  _fading = false;\n\n  /**\n   * The timer that runs function after the fading is complete.\n   * @type {number|null}\n   * @private\n   */\n  _fadeTimer = null;\n\n  /**\n   * Initializes the internal properties.\n   * @param {string|Array<string>|object} args The input parameters of this sound group.\n   * @param {string} [args.id] The unique id of the sound.\n   * @param {string|string[]} args.src Single or array of audio urls/base64 strings.\n   * @param {number} [args.volume = 1.0] The initial volume of the sound. Should be from 0.0 to 1.0.\n   * @param {number} [args.rate = 1] The initial playback rate of the sound. Should be from 0.5 to 5.0.\n   * @param {boolean} [args.loop = false] True to play the sound repeatedly.\n   * @param {boolean} [args.muted = false] True to be muted initially.\n   * @param {boolean} [args.preload = false] True to pre-load the sound after construction.\n   * @param {boolean} [args.autoplay = false] True to play automatically after construction.\n   * @param {string|string[]} [args.format] The file format(s) of the passed audio source(s).\n   * @param {object} [args.sprite] The sprite definition.\n   * @param {function} [args.onload] Event-handler for the \"load\" event.\n   * @param {function} [args.onunload] Event-handler for the \"unload\" event.\n   * @param {function} [args.onplaystart] Event-handler for the \"playstart\" event.\n   * @param {function} [args.onplayend] Event-handler for the \"playend\" event.\n   * @param {function} [args.onstop] Event-handler for the \"stop\" event.\n   * @param {function} [args.onpause] Event-handler for the \"pause\" event.\n   * @param {function} [args.onmute] Event-handler for the \"mute\" event.\n   * @param {function} [args.onvolume] Event-handler for the \"volume\" event.\n   * @param {function} [args.onrate] Event-handler for the \"rate\" event.\n   * @param {function} [args.onseek] Event-handler for the \"seek\" event.\n   * @param {function} [args.onerror] Event-handler for the \"error\" event.\n   * @param {function} [args.ondestroy] Event-handler for the \"destroy\" event.\n   * @constructor\n   */\n  constructor(args) {\n    // Setup the audio engine.\n    this._engine = engine;\n    this._engine.setup();\n    this._engine.on(EngineEvents.Resume, this._onEngineResume = this._onEngineResume.bind(this));\n\n    // If no audio is available throw error.\n    if (!this._engine.isAudioAvailable()) {\n      this._fire(BuzzEvents.Error, null, { type: ErrorType.NoAudio, error: 'Web Audio is un-available' });\n      return this;\n    }\n\n    if (typeof args === 'string') {\n      this._src = [args];\n    } else if (Array.isArray(args) && args.length) {\n      this._src = args;\n    } else if (typeof args === 'object') {\n      const {\n        id,\n        src,\n        format,\n        sprite,\n        volume,\n        rate,\n        muted,\n        loop,\n        autoplay,\n        preload,\n        onload,\n        onunload,\n        onplaystart,\n        onplayend,\n        onstop,\n        onpause,\n        onmute,\n        onvolume,\n        onrate,\n        onseek,\n        onerror,\n        ondestroy\n      } = args;\n\n      // Set the passed id or the random one.\n      this._id = typeof id === 'number' ? id : utility.id();\n\n      // Set the source.\n      if (typeof src === 'string') {\n        this._src = [src];\n      } else if (Array.isArray(src) && src.length) {\n        this._src = src;\n      }\n\n      // Set the format.\n      if (Array.isArray(format)) {\n        this._format = format;\n      } else if (typeof format === 'string' && format) {\n        this._format = [format];\n      }\n\n      // Set other properties.\n      typeof sprite === 'object' && (this._sprite = sprite);\n      typeof volume === 'number' && volume >= 0 && volume <= 1.0 && (this._volume = volume);\n      typeof rate === 'number' && rate >= 0.5 && rate <= 5 && (this._rate = rate);\n      typeof muted === 'boolean' && (this._muted = muted);\n      typeof loop === 'boolean' && (this._loop = loop);\n      typeof autoplay === 'boolean' && (this._autoplay = autoplay);\n      typeof preload === 'boolean' && (this._preload = preload);\n      typeof onload === 'function' && this.on(BuzzEvents.Load, onload);\n      typeof onunload === 'function' && this.on(BuzzEvents.UnLoad, onunload);\n\n      // Bind the passed event handlers to events.\n      typeof onplaystart === 'function' && this.on(BuzzEvents.PlayStart, onplaystart);\n      typeof onplayend === 'function' && this.on(BuzzEvents.PlayEnd, onplayend);\n      typeof onstop === 'function' && this.on(BuzzEvents.Stop, onstop);\n      typeof onpause === 'function' && this.on(BuzzEvents.Pause, onpause);\n      typeof onmute === 'function' && this.on(BuzzEvents.Mute, onmute);\n      typeof onvolume === 'function' && this.on(BuzzEvents.Volume, onvolume);\n      typeof onrate === 'function' && this.on(BuzzEvents.Rate, onrate);\n      typeof onseek === 'function' && this.on(BuzzEvents.Seek, onseek);\n      typeof onerror === 'function' && this.on(BuzzEvents.Error, onerror);\n      typeof ondestroy === 'function' && this.on(BuzzEvents.Destroy, ondestroy);\n    }\n\n    // Throw error if source is not passed.\n    if (!this._src) {\n      throw new Error('You should pass the source for the audio.');\n    }\n\n    // Instantiate the dependencies.\n    this._queue = new Queue();\n\n    if (this._autoplay) {\n      this.play();\n    } else if (this._preload) {\n      this.load();\n    }\n  }\n\n  /**\n   * Loads the sound to the underlying audio object.\n   * @return {Buzz}\n   */\n  load() {\n    // If the sound is already loaded return without reloading again.\n    if (this.isLoaded() || this._loadState === LoadState.Loading) {\n      return this;\n    }\n\n    // Set the state to \"Loading\" to avoid loading multiple times.\n    this._loadState = LoadState.Loading;\n\n    // Get the compatible source.\n    const src = this._compatibleSrc || (this._compatibleSrc = this.getCompatibleSource());\n\n    // If no compatible source found call failure method and return.\n    if (!src) {\n      this._onLoadFailure('The audio formats you passed are not supported');\n      return this;\n    }\n\n    // Load the audio source.\n    this._engine.load(src).then(downloadResult => {\n      // During the time of loading... if the buzz is unloaded or destroyed then return.\n      if (this._loadState === LoadState.NotLoaded || this._state === BuzzState.Destroyed) {\n        return;\n      }\n\n      // If loading succeeded,\n      // i. Save the result.\n      // ii. Set the load state as loaded.\n      // iii. Fire the load event.\n      // iv. Run the methods that are queued to run after successful load.\n      if (downloadResult.status === DownloadStatus.Success) {\n        this._buffer = downloadResult.value;\n        this._duration = this._buffer.duration;\n        this._loadState = LoadState.Loaded;\n        this._fire(BuzzEvents.Load, null, downloadResult);\n        this._queue.run('after-load');\n        return;\n      }\n\n      this._onLoadFailure(downloadResult.error);\n    });\n\n    return this;\n  }\n\n  /**\n   * Called on failure of loading audio source.\n   * @param {*} error The audio source load error.\n   * @private\n   */\n  _onLoadFailure(error) {\n    // Remove the queued actions from this class that are supposed to run after load.\n    this._queue.remove('after-load');\n\n    // Set the load state back to not loaded.\n    this._loadState = LoadState.NotLoaded;\n\n    // Fire the error event.\n    this._fire(BuzzEvents.Error, null, { type: ErrorType.LoadError, error: error });\n  }\n\n  /**\n   * Returns the first compatible source based on the passed sources and the format.\n   * @return {string}\n   */\n  getCompatibleSource() {\n    // If the user has passed \"format\", check if it is supported or else retrieve the first supported source from the array.\n    return this._format.length ?\n      this._src[this._format.indexOf(utility.getSupportedFormat(this._format))] :\n      utility.getSupportedSource(this._src);\n  }\n\n  /**\n   * Plays the passed sound defined in the sprite or the sound that belongs to the passed id.\n   * @param {string|number} [soundOrId] The sound name defined in sprite or the sound id.\n   * @return {Buzz|number}\n   */\n  play(soundOrId) {\n    const isIdPassed = typeof soundOrId === 'number';\n\n    // If id is passed then get the sound from the engine and play it.\n    if (isIdPassed) {\n      const sound = this._engine.sound(soundOrId);\n      sound && this._play(sound);\n      return this;\n    }\n\n    const newSoundId = utility.id(),\n      playSound = () => {\n        const soundArgs = {\n          id: newSoundId,\n          buffer: this._buffer,\n          volume: this._volume,\n          rate: this._rate,\n          muted: this._muted,\n          loop: this._loop,\n          playEndCallback: sound => this._fire(BuzzEvents.PlayEnd, sound.id()),\n          destroyCallback: sound => {\n            this._fire(BuzzEvents.Destroy, sound.id());\n            emitter.clear(sound.id());\n          },\n          fadeEndCallback: sound => this._fire(BuzzEvents.FadeEnd, sound.id())\n        };\n\n        if (typeof soundOrId === 'string' && this._sprite && this._sprite.hasOwnProperty(soundOrId)) {\n          const positions = this._sprite[soundOrId];\n          soundArgs.startPos = positions[0];\n          soundArgs.endPos = positions[1];\n        }\n\n        const newSound = this._engine.sound(this._compatibleSrc, this._id, soundArgs);\n        this._play(newSound);\n      };\n\n    // If the sound is not yet loaded push an action to the queue to play the sound once it's loaded.\n    if (!this.isLoaded()) {\n      this._queue.add('after-load', `play-${newSoundId}`, () => playSound());\n      this.load();\n    } else {\n      playSound();\n    }\n\n    return newSoundId;\n  }\n\n  /**\n   * Pauses the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  pause(id) {\n    this._removePlayActions(id);\n    typeof id !== 'number' && this.fadeStop();\n    this._sounds(id).forEach(sound => sound.pause());\n    this._fire(BuzzEvents.Pause, id);\n\n    return this;\n  }\n\n  /**\n   * Stops the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  stop(id) {\n    this._removePlayActions(id);\n    typeof id !== 'number' && this.fadeStop();\n    this._sounds(id).forEach(sound => sound.stop());\n    this._fire(BuzzEvents.Stop, id);\n\n    return this;\n  }\n\n  /**\n   * Mutes the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  mute(id) {\n    const isGroup = typeof id !== 'number';\n    isGroup && this.fadeStop();\n    this._sounds(id).forEach(sound => sound.mute());\n    isGroup && (this._muted = true);\n\n    this._fire(BuzzEvents.Mute, id, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Un-mutes the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  unmute(id) {\n    const isGroup = typeof id !== 'number';\n    isGroup && this.fadeStop();\n    this._sounds(id).forEach(sound => sound.unmute());\n    isGroup && (this._muted = false);\n\n    this._fire(BuzzEvents.Mute, id, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the volume of the passed sound or the group.\n   * @param {number} [volume] Should be from 0.0 to 1.0.\n   * @param {number} [id] The sound id.\n   * @return {Buzz|number}\n   */\n  volume(volume, id) {\n    const isGroup = typeof id !== 'number';\n\n    if (typeof volume === 'number' && volume >= 0 && volume <= 1.0) {\n      isGroup && this.fadeStop();\n      this._sounds(id).forEach(sound => sound.volume(volume));\n      typeof id !== 'number' && (this._volume = volume);\n      this._fire(BuzzEvents.Volume, id, this._volume);\n      return this;\n    }\n\n    if (!isGroup) {\n      const sound = this._engine.sound(id);\n      return sound ? sound.volume() : null;\n    }\n\n    return this._volume;\n  }\n\n  /**\n   * Fades the group's or passed sound's volume to the passed value in the passed duration.\n   * @param {number} to The destination volume.\n   * @param {number} duration The period of fade in seconds.\n   * @param {string} [type = linear] The fade type (linear or exponential).\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  fade(to, duration, type = 'linear', id) {\n    const isGroup = typeof id !== 'number';\n\n    if (isGroup && this._fading) {\n      return this;\n    }\n\n    this._fire(BuzzEvents.FadeStart, id);\n\n    this._sounds(id).forEach(sound => sound.fade(to, duration, type));\n\n    if (isGroup) {\n      this._fading = true;\n\n      this._fadeTimer = setTimeout(() => {\n        this.volume(to);\n\n        clearTimeout(this._fadeTimer);\n\n        this._fadeTimer = null;\n        this._fading = false;\n        this._fire(BuzzEvents.FadeEnd);\n      }, duration * 1000);\n    }\n\n    return this;\n  }\n\n  /**\n   * Stops the group's or passed sound's current running fade.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  fadeStop(id) {\n    const isGroup = typeof id !== 'number';\n\n    if (isGroup && !this._fading) {\n      return this;\n    }\n\n    this._sounds(id).forEach(sound => sound.fadeStop());\n\n    if (isGroup) {\n      if (this._fadeTimer) {\n        clearTimeout(this._fadeTimer);\n        this._fadeTimer = null;\n      }\n\n      this._fading = false;\n    }\n\n    this._fire(BuzzEvents.FadeStop, id);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the rate of the passed sound or the group.\n   * @param {number} [rate] Should be from 0.5 to 5.0.\n   * @param {number} [id] The sound id.\n   * @return {Buzz|number}\n   */\n  rate(rate, id) {\n    if (typeof rate === 'number' && rate >= 0.5 && rate <= 5) {\n      this._sounds(id).forEach(sound => sound.rate(rate));\n      typeof id !== 'number' && (this._rate = rate);\n      this._fire(BuzzEvents.Rate, id, this._rate);\n      return this;\n    }\n\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.rate() : null;\n    }\n\n    return this._rate;\n  }\n\n  /**\n   * Gets/sets the current playback position of the sound.\n   * @param {number} id The sound id\n   * @param {number} [seek] The seek position.\n   * @return {Buzz|number}\n   */\n  seek(id, seek) {\n    const sound = this._engine.sound(id);\n\n    if (!sound) {\n      return this;\n    }\n\n    if (typeof seek === 'number') {\n      // If the audio source is not yet loaded push an item to the queue to seek after the sound is loaded\n      // and load the sound.\n      if (!this.isLoaded()) {\n        this._queue.add('after-load', `seek-${id}`, () => this.seek(id, seek));\n        this.load();\n        return this;\n      }\n\n      sound.seek(seek);\n      this._fire(BuzzEvents.Seek, id, seek);\n      return this;\n    }\n\n    return sound.seek();\n  }\n\n  /**\n   * Gets/sets the looping behavior of a sound or the group.\n   * @param {boolean} [loop] True to loop the sound.\n   * @param {number} [id] The sound id.\n   * @return {Buzz|boolean}\n   */\n  loop(loop, id) {\n    if (typeof loop === 'boolean') {\n      this._sounds(id).forEach(sound => sound.loop(loop));\n      typeof id !== 'number' && (this._loop = loop);\n      return this;\n    }\n\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.loop() : null;\n    }\n\n    return this._loop;\n  }\n\n  /**\n   * Returns true if the passed sound is playing.\n   * @param {number} id The sound id.\n   * @return {boolean}\n   */\n  playing(id) {\n    const sound = this._engine.sound(id);\n    return sound ? sound.isPlaying() : null;\n  }\n\n  /**\n   * Returns true if the passed sound is muted or the group is muted.\n   * @param {number} [id] The sound id.\n   * @return {boolean}\n   */\n  muted(id) {\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.muted() : null;\n    }\n\n    return this._muted;\n  }\n\n  /**\n   * Returns the state of the passed sound or the group.\n   * @return {BuzzState|SoundState}\n   */\n  state(id) {\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.state() : null;\n    }\n\n    return this._state;\n  }\n\n  /**\n   * Returns the duration of the passed sound or the total duration of the sound.\n   * @param {number} [id] The sound id.\n   * @return {number}\n   */\n  duration(id) {\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.duration() : null;\n    }\n\n    return this._duration;\n  }\n\n  /**\n   * Unloads the loaded audio buffer.\n   * @return {Buzz}\n   */\n  unload() {\n    this._queue.remove('after-load');\n    this._engine.unload(this._compatibleSrc);\n    this._buffer = null;\n    this._duration = 0;\n    this._loadState = LoadState.NotLoaded;\n    return this;\n  }\n\n  /**\n   * Stops and destroys all the sounds belong to this group and release other dependencies.\n   */\n  destroy() {\n    if (this._state === BuzzState.Destroyed) {\n      return;\n    }\n\n    this.stop();\n    this._queue.clear();\n    this._engine.off(EngineEvents.Resume, this._onEngineResume);\n    this._engine.free(false, this._id);\n\n    this._buffer = null;\n    this._queue = null;\n    this._engine = null;\n    this._state = BuzzState.Destroyed;\n\n    this._fire(BuzzEvents.Destroy);\n\n    emitter.clear(this._id);\n  }\n\n  /**\n   * Subscribes to an event for the sound or the group.\n   * @param {string} eventName The event name.\n   * @param {function} handler The event handler.\n   * @param {boolean} [once = false] True for one-time event handling.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  on(eventName, handler, once = false, id) {\n    emitter.on(id || this._id, eventName, handler, once);\n    return this;\n  }\n\n  /**\n   * Un-subscribes from an event for the sound or the group.\n   * @param {string} eventName The event name.\n   * @param {function} handler The event handler.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  off(eventName, handler, id) {\n    emitter.off(id || this._id, eventName, handler);\n    return this;\n  }\n\n  /**\n   * Returns the unique id of the sound.\n   * @return {number}\n   */\n  id() {\n    return this._id;\n  }\n\n  /**\n   * Returns the audio resource loading status.\n   * @return {LoadState}\n   */\n  loadState() {\n    return this._loadState;\n  }\n\n  /**\n   * Returns true if the audio source is loaded.\n   * @return {boolean}\n   */\n  isLoaded() {\n    return this._loadState === LoadState.Loaded;\n  }\n\n  /**\n   * Returns the sound for the passed id.\n   * @param {number} id The sound id.\n   * @return {Sound}\n   */\n  sound(id) {\n    return this._engine.sound(id);\n  }\n\n  /**\n   * Returns true if the passed sound exists.\n   * @param {number} id The sound id.\n   * @return {boolean}\n   */\n  alive(id) {\n    return Boolean(this.sound(id));\n  }\n\n  /**\n   * Whenever the engine resume run the actions queued for it.\n   * @private\n   */\n  _onEngineResume() {\n    this._queue.run('after-engine-resume');\n  }\n\n  /**\n   * Checks the engine state and plays the passed sound.\n   * @param {Sound} sound The sound.\n   * @private\n   */\n  _play(sound) {\n    if (this._engine.state() === EngineState.Destroying || this._engine.state() === EngineState.Done) {\n      this._fire(BuzzEvents.Error, null, { type: ErrorType.PlayError, error: 'The engine is stopping/stopped' });\n      return;\n    }\n\n    if (this._engine.state() === EngineState.NoAudio) {\n      this._fire(BuzzEvents.Error, null, { type: ErrorType.NoAudio, error: 'Web Audio is un-available' });\n      return;\n    }\n\n    const playAndFire = () => {\n      sound.play();\n      this._fire(BuzzEvents.PlayStart, sound.id());\n    };\n\n    if ([EngineState.Suspending, EngineState.Suspended, EngineState.Resuming].indexOf(this._engine.state()) > -1) {\n      this._queue.add('after-engine-resume', `sound-${sound.id()}`, () => playAndFire());\n      this._engine.state() !== EngineState.Resuming && this._engine.resume();\n      return;\n    }\n\n    playAndFire();\n  }\n\n  /**\n   * Remove the play actions queued from the queue.\n   * @param {number} [id] The sound id.\n   * @private\n   */\n  _removePlayActions(id) {\n    this._queue.remove('after-load', id ? `play-${id}` : null);\n    this._queue.remove('after-engine-resume', id ? `sound-${id}` : null);\n  }\n\n  /**\n   * Returns the sound for the passed id or all the sounds belong to this group.\n   * @param {number} [id] The sound id.\n   * @return {Array<Sound>}\n   * @private\n   */\n  _sounds(id) {\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? [sound] : [];\n    }\n\n    return this._engine.sounds(this._id);\n  }\n\n  /**\n   * Fires an event of group or sound.\n   * @param {string} eventName The event name.\n   * @param {number} [id] The sound id.\n   * @param {...*} args The arguments that to be passed to handler.\n   * @return {Buzz}\n   * @private\n   */\n  _fire(eventName, id, ...args) {\n    if (id) {\n      emitter.fire(id, eventName, ...args, this.sound(id), this);\n      emitter.fire(this._id, eventName, ...args, this.sound(id), this);\n    } else {\n      emitter.fire(this._id, eventName, ...args, this);\n    }\n\n    return this;\n  }\n}\n\nconst $buzz = args => new Buzz(args);\n[\n  'setup',\n  'load',\n  'unload',\n  'mute',\n  'unmute',\n  'volume',\n  'stop',\n  'suspend',\n  'resume',\n  'terminate',\n  'muted',\n  'state',\n  'context',\n  'isAudioAvailable',\n  'on',\n  'off'\n].forEach(method => {\n  $buzz[method] = function () {\n    const result = engine[method](...arguments);\n    return result === engine ? $buzz : result;\n  };\n});\n\nmodule.exports = $buzz;\n","/**\n * Represents a heap item.\n */\nclass HeapItem {\n\n  /**\n   * The sound object.\n   * @type {Sound}\n   */\n  sound = null;\n\n  /**\n   * The group id.\n   * @type {number|null}\n   */\n  groupId = null;\n\n  /**\n   * Set the group id and sound.\n   * @param {number} groupId The group id.\n   * @param {Sound} sound The sound instance.\n   */\n  constructor(groupId, sound) {\n    this.groupId = groupId;\n    this.sound = sound;\n  }\n}\n\n/**\n * Represents a collection of sounds belong to an audio resource.\n */\nclass HeapItemCollection {\n\n  /**\n   * The audio source url.\n   * @type {string|null}\n   */\n  url = null;\n\n  /**\n   * The collection of sound objects.\n   * @type {object}\n   */\n  items = {};\n\n  /**\n   * Adds a new sound item to the collection.\n   * @param {number} groupId The group id.\n   * @param {Sound} sound The sound instance.\n   */\n  add(groupId, sound) {\n    const soundId = sound.id().toString();\n\n    if (this.items.hasOwnProperty(soundId)) {\n      return;\n    }\n\n    this.items[soundId] = new HeapItem(groupId, sound);\n  }\n\n  /**\n   * Removes the sounds.\n   * @param {boolean} [idle = true] True to destroy only the idle sounds.\n   * @param {number} [groupId] The group id.\n   */\n  free(idle = true, groupId) {\n    Object.values(this.items).forEach(item => {\n      const { sound, soundGroupId } = item;\n\n      if(idle && (sound.isPlaying() || sound.isPaused())) {\n        return;\n      }\n\n      if (!Boolean(groupId) || soundGroupId === groupId) {\n        sound.destroy();\n        delete this.items[sound.id()];\n      }\n    });\n  }\n\n  /**\n   * Returns the sounds belong to the group or all the sounds in the collection.\n   * @param {number} [groupId] The group id.\n   * @return {Array<HeapItem>}\n   */\n  sounds(groupId) {\n    const itemsArray = Object.values(this.items);\n    const items = groupId ? itemsArray.filter(item => item.groupId === groupId) : itemsArray;\n    return items.map(item => item.sound);\n  }\n\n  /**\n   * Destroys all the sounds.\n   */\n  destroy() {\n    Object.values(this.items).forEach(item => item.sound.destroy());\n    this.items = {};\n  }\n}\n\n/**\n * Stores all the created sounds.\n */\nclass Heap {\n\n  /**\n   * The sound collections.\n   * @type {object}\n   * @private\n   */\n  _collections = {};\n\n  /**\n   * Initialize stuff.\n   */\n  constructor() {\n    this.free = this.free.bind(this);\n  }\n\n  /**\n   * Adds a new sound to the respective collection.\n   * @param {string} url The audio source url or base64 string.\n   * @param {number} groupId The group id.\n   * @param {Sound} sound The sound instance.\n   */\n  add(url, groupId, sound) {\n    if (!this._collections.hasOwnProperty(url)) {\n      this._collections[url] = new HeapItemCollection();\n    }\n\n    this._collections[url].add(groupId, sound);\n  }\n\n  /**\n   * Returns the sound based on the id.\n   * @param {number} id The sound id.\n   */\n  sound(id) {\n    return this.sounds().find(sound => sound.id() === id);\n  }\n\n  /**\n   * Returns the sounds belongs to a particular group or all of them.\n   * @param {number} [groupId] The group id.\n   * @return {Array}\n   */\n  sounds(groupId) {\n    const sounds = [];\n    Object.values(this._collections).forEach(col => sounds.push(...col.sounds(groupId)));\n    return sounds;\n  }\n\n  /**\n   * Removes sounds from the collections.\n   * @param {boolean} [idle = true] True to destroy only the idle sounds.\n   * @param {number} [groupId] The group id.\n   */\n  free(idle = true, groupId) {\n    Object.values(this._collections).forEach(col => col.free(idle, groupId));\n  }\n\n  /**\n   * Destroys all the sounds.\n   */\n  destroy() {\n    Object.values(this._collections).forEach(col => col.destroy());\n    this._collections = {};\n  }\n}\n\nexport default Heap;\n","import engine from './Engine';\nimport utility from './Utility';\n\n/**\n * Enum that represents the different states of a sound.\n * @enum {string}\n */\nconst SoundState = {\n  Ready: 'ready',\n  Playing: 'playing',\n  Paused: 'paused',\n  Destroyed: 'destroyed'\n};\n\n/**\n * Represents a sound created using Web Audio API.\n * @class\n */\nclass Sound {\n\n  /**\n   * Unique id.\n   * @type {number}\n   * @private\n   */\n  _id = -1;\n\n  /**\n   * The current volume of the sound. Should be from 0.0 to 1.0.\n   * @type {number}\n   * @private\n   */\n  _volume = 1.0;\n\n  /**\n   * The current playback speed. Should be from 0.5 to 5.\n   * @type {number}\n   * @private\n   */\n  _rate = 1;\n\n  /**\n   * True if the sound is currently muted.\n   * @type {boolean}\n   * @private\n   */\n  _muted = false;\n\n  /**\n   * True if the sound should play repeatedly.\n   * @type {boolean}\n   * @private\n   */\n  _loop = false;\n\n  /**\n   * The current state (playing, paused etc.) of the sound.\n   * @type {SoundState}\n   * @private\n   */\n  _state = SoundState.Ready;\n\n  /**\n   * Web API's audio context.\n   * @type {AudioContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * The gain node to control the volume of the sound.\n   * @type {GainNode}\n   * @private\n   */\n  _gainNode = null;\n\n  /**\n   * The audio buffer.\n   * @type {AudioBuffer}\n   * @private\n   */\n  _buffer = null;\n\n  /**\n   * The AudioBufferSourceNode that plays the audio buffer assigned to it.\n   * @type {AudioBufferSourceNode}\n   * @private\n   */\n  _bufferSourceNode = null;\n\n  /**\n   * Duration of the playback in seconds.\n   * @type {number}\n   * @private\n   */\n  _duration = 0;\n\n  /**\n   * The playback start position.\n   * @type {number}\n   * @private\n   */\n  _startPos = 0;\n\n  /**\n   * The playback end position.\n   * @type {number}\n   * @private\n   */\n  _endPos = 0;\n\n  /**\n   * The current position of the playback.\n   * @type {number}\n   * @private\n   */\n  _currentPos = 0;\n\n  /**\n   * The position of the playback during rate change.\n   * @type {number}\n   * @private\n   */\n  _rateSeek = 0;\n\n  /**\n   * The time at which the playback started.\n   * This property is required for getting the seek position of the playback.\n   * @type {number}\n   * @private\n   */\n  _startTime = 0;\n\n  /**\n   * The callback that will be invoked after the play ends.\n   * @type {function}\n   * @private\n   */\n  _playEndCallback = null;\n\n  /**\n   * The callback that will be invoked after the sound destroyed.\n   * @type {function}\n   * @private\n   */\n  _destroyCallback = null;\n\n  /**\n   * True if the sound is currently fading.\n   * @type {boolean}\n   * @private\n   */\n  _fading = false;\n\n  /**\n   * The timer that runs function after the fading is complete.\n   * @type {number|null}\n   * @private\n   */\n  _fadeTimer = null;\n\n  /**\n   * The callback that will be invoked after the fade is completed.\n   * @type {function}\n   * @private\n   */\n  _fadeEndCallback = null;\n\n  /**\n   * Initializes the internal properties of the sound.\n   * @param {object} args The input parameters of the sound.\n   * @param {string} [args.id] The unique id of the sound.\n   * @param {AudioBuffer} [args.buffer] Audio source buffer.\n   * @param {number} [args.volume = 1.0] The initial volume of the sound. Should be from 0.0 to 1.0.\n   * @param {number} [args.rate = 1] The initial playback rate of the sound. Should be from 0.5 to 5.0.\n   * @param {boolean} [args.loop = false] True to play the sound repeatedly.\n   * @param {boolean} [args.muted = false] True to be muted initially.\n   * @param {number} [args.startPos] The playback start position.\n   * @param {number} [args.endPos] The playback end position.\n   * @param {function} [args.playEndCallback] The callback that will be invoked after the play ends.\n   * @param {function} [args.destroyCallback] The callback that will be invoked after destroyed.\n   * @param {function} [args.fadeEndCallback] The callback that will be invoked the fade is completed.\n   * @constructor\n   */\n  constructor(args) {\n    const {\n      id,\n      buffer,\n      volume,\n      rate,\n      loop,\n      muted,\n      startPos,\n      endPos,\n      playEndCallback,\n      destroyCallback,\n      fadeEndCallback\n    } = args;\n\n    // Set the passed id or the random one.\n    this._id = typeof id === 'number' ? id : utility.id();\n\n    // Set the passed audio buffer and duration.\n    this._buffer = buffer;\n    this._endPos = this._buffer.duration;\n\n    // Set other properties.\n    volume && (this._volume = volume);\n    rate && (this._rate = rate);\n    muted && (this._muted = muted);\n    loop && (this._loop = loop);\n    startPos && (this._startPos = startPos);\n    endPos && (this._endPos = endPos);\n    this._playEndCallback = playEndCallback;\n    this._destroyCallback = destroyCallback;\n    this._fadeEndCallback = fadeEndCallback;\n\n    // Calculate the duration.\n    this._duration = this._endPos - this._startPos;\n\n    // Create gain node and set the volume.\n    this._context = engine.context();\n    this._gainNode = this._context.createGain();\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : this._volume, this._context.currentTime);\n  }\n\n  /**\n   * Plays the sound or the sound defined in the sprite.\n   * @return {Sound}\n   */\n  play() {\n    // If the sound is already playing then return.\n    if (this.isPlaying()) {\n      return this;\n    }\n\n    // Get the playback starting position.\n    let seek = Math.max(0, this._currentPos > 0 ? this._currentPos : this._startPos);\n\n    // Create a new buffersourcenode to play the sound.\n    this._bufferSourceNode = this._context.createBufferSource();\n\n    // Set the buffer, playback rate and loop parameters\n    this._bufferSourceNode.buffer = this._buffer;\n    this._bufferSourceNode.playbackRate.setValueAtTime(this._rate, this._context.currentTime);\n    this._setLoop(this._loop);\n\n    // Connect the node to the audio graph.\n    this._bufferSourceNode.connect(this._gainNode);\n\n    // Listen to the \"ended\" event to reset/clean things.\n    this._bufferSourceNode.addEventListener('ended', () => {\n      // Reset the seek positions\n      this._currentPos = 0;\n      this._rateSeek = 0;\n\n      // Destroy the node (AudioBufferSourceNodes are one-time use and throw objects).\n      this._destroyBufferNode();\n\n      // Reset the state to allow future actions.\n      this._state = SoundState.Ready;\n\n      // Invoke the callback if there is one.\n      this._playEndCallback && this._playEndCallback(this);\n    });\n\n    const startTime = this._context.currentTime;\n\n    // Call the supported method to play the sound.\n    if (typeof this._bufferSourceNode.start !== 'undefined') {\n      this._bufferSourceNode.start(startTime, seek, this._loop ? undefined : this._duration);\n    } else {\n      this._bufferSourceNode.noteGrainOn(startTime, seek, this._loop ? undefined : this._duration);\n    }\n\n    // Record the starting time and set the state.\n    this._startTime = startTime;\n    this._state = SoundState.Playing;\n\n    return this;\n  }\n\n  /**\n   * Pauses the playing sound.\n   * @return {Sound}\n   */\n  pause() {\n    // If the sound is already playing return.\n    if (!this.isPlaying()) {\n      return this;\n    }\n\n    // Stop the current running fade.\n    this.fadeStop();\n\n    // Save the current position and reset rateSeek.\n    this._currentPos = this.seek();\n    this._rateSeek = 0;\n\n    this._destroyBufferNode();\n\n    this._state = SoundState.Paused;\n\n    return this;\n  }\n\n  /**\n   * Stops the sound that is playing or in paused state.\n   * @return {Sound}\n   */\n  stop() {\n    // If the sound is not playing or paused return.\n    if (!this.isPlaying() && !this.isPaused()) {\n      return this;\n    }\n\n    // Stop the current running fade.\n    this.fadeStop();\n\n    // Reset the variables\n    this._currentPos = 0;\n    this._rateSeek = 0;\n\n    this._destroyBufferNode();\n\n    this._state = SoundState.Ready;\n\n    return this;\n  }\n\n  /**\n   * Mutes the sound.\n   * @return {Sound}\n   */\n  mute() {\n    // Stop the current running fade.\n    this.fadeStop();\n\n    // Set the value of gain node to 0.\n    this._gainNode.gain.setValueAtTime(0, this._context.currentTime);\n\n    // Set the muted property true.\n    this._muted = true;\n\n    return this;\n  }\n\n  /**\n   * Un-mutes the sound.\n   * @return {Sound}\n   */\n  unmute() {\n    // Stop the current running fade.\n    this.fadeStop();\n\n    // Reset the gain node's value back to volume.\n    this._gainNode.gain.setValueAtTime(this._volume, this._context.currentTime);\n\n    // Set the muted property to false.\n    this._muted = false;\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the volume.\n   * @param {number} [vol] Should be from 0.0 to 1.0.\n   * @return {Sound|number}\n   */\n  volume(vol) {\n    // If no input parameter is passed then return the volume.\n    if (typeof vol === 'undefined') {\n      return this._volume;\n    }\n\n    // Stop the current running fade.\n    this.fadeStop();\n\n    // Set the gain's value to the passed volume.\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : vol, this._context.currentTime);\n\n    // Set the volume to the property.\n    this._volume = vol;\n\n    return this;\n  }\n\n  /**\n   * Fades the sound volume to the passed value in the passed duration.\n   * @param {number} to The destination volume.\n   * @param {number} duration The period of fade.\n   * @param {string} [type = linear] The fade type (linear or exponential).\n   * @return {Sound}\n   */\n  fade(to, duration, type = 'linear') {\n    // If a fade is already running stop it.\n    if (this._fading) {\n      this.fadeStop();\n    }\n\n    this._fading = true;\n\n    if (type === 'linear') {\n      this._gainNode.gain.linearRampToValueAtTime(to, this._context.currentTime + duration);\n    } else {\n      this._gainNode.gain.exponentialRampToValueAtTime(to, this._context.currentTime + duration);\n    }\n\n    this._fadeTimer = setTimeout(() => {\n      this.volume(to);\n\n      clearTimeout(this._fadeTimer);\n\n      this._fadeTimer = null;\n      this._fading = false;\n\n      this._fadeEndCallback && this._fadeEndCallback(this);\n    }, duration * 1000);\n\n    return this;\n  }\n\n  /**\n   * Stops the current running fade.\n   * @return {Sound}\n   */\n  fadeStop() {\n    if (!this._fading) {\n      return this;\n    }\n\n    this._gainNode.gain.cancelScheduledValues(this._context.currentTime);\n\n    if (this._fadeTimer) {\n      clearTimeout(this._fadeTimer);\n      this._fadeTimer = null;\n    }\n\n    this._fading = false;\n    this.volume(this._gainNode.gain.value);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the playback rate.\n   * @param {number} [rate] The playback rate. Should be from 0.5 to 5.\n   * @return {Sound|number}\n   */\n  rate(rate) {\n    // If no input parameter is passed return the current rate.\n    if (typeof rate === 'undefined') {\n      return this._rate;\n    }\n\n    this._rate = rate;\n    this._rateSeek = this.seek();\n\n    if (this.isPlaying()) {\n      this._startTime = this._context.currentTime;\n      this._bufferSourceNode && (this._bufferSourceNode.playbackRate.setValueAtTime(rate, this._context.currentTime));\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the seek position.\n   * @param {number} [seek] The seek position.\n   * @return {Sound|number}\n   */\n  seek(seek) {\n    // If no parameter is passed return the current position.\n    if (typeof seek === 'undefined') {\n      const realTime = this.isPlaying() ? this._context.currentTime - this._startTime : 0;\n      const rateElapsed = this._rateSeek ? this._rateSeek - this._currentPos : 0;\n\n      return this._currentPos + (rateElapsed + realTime * this._rate);\n    }\n\n    // If seeking outside the borders then return.\n    if (seek < this._startPos || seek > this._endPos) {\n      return this;\n    }\n\n    // If the sound is currently playing... pause it, set the seek position and then continue playing.\n    const isPlaying = this.isPlaying();\n\n    if (isPlaying) {\n      this.pause();\n    }\n\n    this._currentPos = seek;\n\n    if (isPlaying) {\n      this.play();\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the loop parameter of the sound.\n   * @param {boolean} [loop] True to loop the sound.\n   * @return {Sound/boolean}\n   */\n  loop(loop) {\n    if (typeof loop !== 'boolean') {\n      return this._loop;\n    }\n\n    this._loop = loop;\n    this._setLoop(loop);\n\n    return this;\n  }\n\n  /**\n   * Destroys the dependencies and release the memory.\n   * @return {Sound}\n   */\n  destroy() {\n    // If the sound is already destroyed return.\n    if (this._state === SoundState.Destroyed) {\n      return this;\n    }\n\n    // Stop the sound.\n    this.stop();\n\n    this._gainNode.disconnect();\n\n    this._buffer = null;\n    this._context = null;\n    this._gainNode = null;\n\n    // Set the state to \"destroyed\".\n    this._state = SoundState.Destroyed;\n\n    this._destroyCallback && this._destroyCallback(this);\n\n    return this;\n  }\n\n  /**\n   * Returns the unique id of the sound.\n   * @return {number}\n   */\n  id() {\n    return this._id;\n  }\n\n  /**\n   * Returns whether the sound is muted or not.\n   * @return {boolean}\n   */\n  muted() {\n    return this._muted;\n  }\n\n  /**\n   * Returns the state of the sound.\n   * @return {SoundState}\n   */\n  state() {\n    return this._state;\n  }\n\n  /**\n   * Returns the total duration of the playback.\n   * @return {number}\n   */\n  duration() {\n    return this._duration;\n  }\n\n  /**\n   * Returns true if the buzz is playing.\n   * @return {boolean}\n   */\n  isPlaying() {\n    return this._state === SoundState.Playing;\n  }\n\n  /**\n   * Returns true if buzz is paused.\n   * @return {boolean}\n   */\n  isPaused() {\n    return this._state === SoundState.Paused;\n  }\n\n  /**\n   * Returns the gain node.\n   * @return {GainNode}\n   */\n  _gain() {\n    return this._gainNode;\n  }\n\n  /**\n   * Stops the playing buffer source node and destroys it.\n   * @private\n   */\n  _destroyBufferNode() {\n    if (!this._bufferSourceNode) {\n      return;\n    }\n\n    if (typeof this._bufferSourceNode.stop !== 'undefined') {\n      this._bufferSourceNode.stop();\n    }\n    else {\n      this._bufferSourceNode.noteGrainOff();\n    }\n\n    this._bufferSourceNode.disconnect();\n    this._bufferSourceNode.removeEventListener('ended', this._onEnded);\n    this._bufferSourceNode = null;\n  }\n\n  /**\n   * Sets the sound to play repeatedly or not.\n   * @param {boolean} loop True to play the sound repeatedly.\n   * @private\n   */\n  _setLoop(loop) {\n    if (!this._bufferSourceNode) {\n      return;\n    }\n\n    this._bufferSourceNode.loop = loop;\n\n    if (loop) {\n      this._bufferSourceNode.loopStart = this._startPos;\n      this._bufferSourceNode.loopEnd = this._endPos;\n    }\n  }\n}\n\nexport {Sound as default, SoundState};\n"],"sourceRoot":""}